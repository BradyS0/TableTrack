# built using copilot
name: Build and Test API (docker-compose)

on: [push, pull_request]

jobs:
  compose-build-and-smoke:
    runs-on: ubuntu-latest
    env:
      DB_USER: user
      DB_PASSWORD: password
      DB_NAME: mydb_test
      DB_PORT: 5432
      API_PORT: 3000
      PORT: 3000
      NODE_ENV: test
      # Give docker compose longer HTTP timeout to avoid transient CI timeouts
      COMPOSE_HTTP_TIMEOUT: 30
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Install Docker Compose CLI plugin on runner
        run: |
          set -eux
          PLUGINS_DIR="$HOME/.docker/cli-plugins"
          mkdir -p "$PLUGINS_DIR"
          COMPOSE_VERSION="v2.20.2"
          arch=$(uname -m)
          if [ "$arch" = "x86_64" ]; then
            bin_arch="linux-x86_64"
          elif [ "$arch" = "aarch64" ] || [ "$arch" = "arm64" ]; then
            bin_arch="linux-aarch64"
          else
            echo "Unsupported arch: $arch" >&2
            exit 1
          fi
          curl -sSL "https://github.com/docker/compose/releases/download/${COMPOSE_VERSION}/docker-compose-${bin_arch}" -o "$PLUGINS_DIR/docker-compose"
          chmod +x "$PLUGINS_DIR/docker-compose"
          docker compose version

      - name: Build and bring up services (docker-compose)
        working-directory: source
        run: |
          # Force recreate to avoid using stale containers between runs
          docker compose up --build --force-recreate -d

      - name: Fail if required secrets are missing
        working-directory: source
        run: |
          if [ -z "${DB_PASSWORD}" ]; then
            echo "Missing required secret: DB_PASSWORD" >&2
            exit 1
          fi

      - name: Wait for Postgres
        working-directory: source
        run: |
          # Wait until Postgres is ready
          until docker compose exec -T db pg_isready -U ${DB_USER:-user}; do
            echo "Waiting for Postgres..."
            sleep 1
          done

      - name: Host-level smoke check (poll API)
        working-directory: source
        run: |
          SMOKE_PATH="/health"
          SMOKE_TIMEOUT=30
          API_PORT=${API_PORT:-3000}
          echo "Waiting up to ${SMOKE_TIMEOUT}s for API at http://localhost:${API_PORT}${SMOKE_PATH}"
          elapsed=0
          interval=2
          while ! curl -sSf "http://localhost:${API_PORT}${SMOKE_PATH}" -o /dev/null; do
            sleep $interval
            elapsed=$((elapsed + interval))
            echo "Waiting for API... ${elapsed}s"
            if [ "$elapsed" -ge "$SMOKE_TIMEOUT" ]; then
              echo "API did not become ready after ${SMOKE_TIMEOUT}s" >&2
              docker compose ps
              docker compose logs --no-color --tail=200
              exit 1
            fi
          done
          echo "API is responding"

      - name: Collect logs
        if: failure()
        working-directory: source
        run: docker compose logs --no-color --tail=200

      - name: Tear down compose
        if: always()
        working-directory: source
        run: |
          docker compose down -v
          # remove temporary .env created from secrets (do not leave secrets in the repo)
          if [ -f .env ]; then rm .env; fi
